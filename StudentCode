#include <iostream>
#include<chrono>

using namespace std;

class Node
{
public:
	int value;
	Node* rightSubtree;
	Node* leftSubtree;
	int Height;


};
Node* CreateNode(int aValue)
{
	Node* aNode = new Node;
	aNode->value = aValue;
	aNode->rightSubtree = NULL;
	aNode->leftSubtree = NULL;
	aNode->Height = 1;
	return aNode;
}
//To calculate if a key being inserted
//is less than or greater than the node
//it is being compared to.
int Height(Node* atNode)
{
	return atNode == NULL ? 0 : atNode->Height;
}

int Max(int a, int b)
{
	return a > b ? a : b;
}

int Balance(Node* aNode)
{
	return Height(aNode->leftSubtree) - Height(aNode->rightSubtree);
}

Node* Sling(Node* ProblemRoot, int Imbalance)
{
	Node* NewRoot = NULL;
	if (Imbalance < 0)
	{
		//Left Rotation
		//Right subtree becomes root
		//Right subtree's left subtree
		//becomes new root's left subtree's right subtree

		NewRoot = ProblemRoot->rightSubtree;
		Node* temporary = NewRoot->leftSubtree;
		NewRoot->leftSubtree = ProblemRoot;
		ProblemRoot->rightSubtree = temporary;

		ProblemRoot->Height = Max(Height(ProblemRoot->leftSubtree), Height(ProblemRoot->rightSubtree)) + 1;
		NewRoot->Height = Max(Height(NewRoot->leftSubtree), Height(NewRoot->rightSubtree)) + 1;
		return NewRoot;
	}
	else
	{
		//RightRotation
		//Left subtree becomes root
		//Left subtree's right subtree
		//becomes new root's right subtree's left subtree

		NewRoot = ProblemRoot->leftSubtree;
		Node* temporary = NewRoot->rightSubtree;
		NewRoot->rightSubtree = ProblemRoot;
		ProblemRoot->leftSubtree = temporary;

		ProblemRoot->Height = Max(Height(ProblemRoot->leftSubtree), Height(ProblemRoot->rightSubtree)) + 1;
		NewRoot->Height = Max(Height(NewRoot->leftSubtree), Height(NewRoot->rightSubtree)) + 1;

		return NewRoot;
	}
}

Node* Swap(Node* ProblemRoot, int Imbalance)
{
	if (Imbalance < 0)
	{
		//Right rotate right child
		ProblemRoot->rightSubtree = Sling(ProblemRoot->rightSubtree, 2);
		//Right rotate root
		ProblemRoot = Sling(ProblemRoot, -2);
	}
	else
	{
		//Left rotate left child
		ProblemRoot->leftSubtree = Sling(ProblemRoot->leftSubtree, -2);
		//Left rotate root
		ProblemRoot = Sling(ProblemRoot, 2);
	}

	return ProblemRoot;
}


Node* Insert(Node* AtNode, int key)
{
	//First, figure out where to put the node
	//Go down the subtree to find where to put the node,
	//But then you must also come back up the tree.
	if (AtNode == NULL)
		return(CreateNode(key));

	if (key > AtNode->value)
		AtNode->rightSubtree = Insert(AtNode->rightSubtree, key);

	if (key < AtNode->value)
		AtNode->leftSubtree = Insert(AtNode->leftSubtree, key);

	//Update height
	AtNode->Height = Max(Height(AtNode->leftSubtree), Height(AtNode->rightSubtree)) + 1;


	//When coming back up all the way to the root,
	//Make sure that every Node still has balance.

	int balance = Balance(AtNode);

	if (balance > 1)
	{
		if (Balance(AtNode->leftSubtree) < 0)
		{
			return Swap(AtNode, balance);
		}
		else
			return Sling(AtNode, balance);
	}

	if (balance < -1)
	{
		{
			if (Balance(AtNode->rightSubtree) > 0)
			{
				return Swap(AtNode, balance);
			}
			else
				return Sling(AtNode, balance);
		}
	}

	return AtNode;
}
void preOrder(Node *root)
{
	if (root != NULL)
	{
		cout << root->value << " ";
		preOrder(root->leftSubtree);
		preOrder(root->rightSubtree);
	}
}

void main()
{

	Node* Root = CreateNode(10);
	Root = Insert(Root, 5);
	Root = Insert(Root, 2);
	Root = Insert(Root, 7);
	Root = Insert(Root, 3);
	Root = Insert(Root, 11);
	Root = Insert(Root, 15);
	Root = Insert(Root, 20);
	Root = Insert(Root, 13);

	preOrder(Root);

	system("PAUSE");
	return;
}
