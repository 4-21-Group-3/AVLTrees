#include <iostream>
using namespace std;

class Node
{
public:
	int value;
	Node* rightSubtree;
	Node* leftSubtree;
	int Height;

	CreateNode(int aValue)
	{
		value = aValue;
		rightSubtree = NULL;
		leftSubtree = NULL;
		Height = 1;
	}
};

//To calculate if a key being inserted
//is less than or greater than the node
//it is being compared to.
int Max(int a, int b)
{
	return a > b ? a : b;
}

Node* Sling(Node* ProblemRoot, int Imbalance)
{
	Node* NewRoot = NULL;
	if(Imbalance>0)
	{
	//Left Rotation
	//Right subtree becomes root
	//Right subtree's left subtree
	//becomes new root's left subtree's right subtree
	
	NewRoot = ProblemRoot-rightSubtree;
	Node* temporary = NewRoot->leftSubtree;
	NewRoot->leftSubtree = ProblemRoot;
	ProblemRoot->rightSubtree = temporary;
	
	return NewRoot;
	}
	else
	{
	//RightRotation
	//Left subtree becomes root
	//Left subtree's right subtree
	//becomes new root's right subtree's left subtree
	
	NewRoot = ProblemRoot-leftSubtree;
	Node* temporary = NewRoot->rightSubtree;
	NewRoot->rightSubtree = ProblemRoot;
	ProblemRoot->leftSubtree = temporary;
	
	return NewRoot;
	}
}

Node* Swap(Node* ProblemRoot, int Imbalance)
{
	if(Imbalance>0)
	{
	//Left rotate left child
	ProblemRoot->leftSubtree = Sling(ProblemRoot->leftSubtree)
	ProblemRoot
	//Right rotate root
	}
	else
	{
	//Right rotate child right child
	//Left rotate root
	}
}
}

Node* Insert(Node* AtNode, int key)
{
	//First, figure out where to put the node
	//Go down the subtree to find where to put the node,
	//But then you must also come back up the tree.
	if (AtNode == NULL)
		return(CreateNode(key));

	if (key > AtNode->value)
		AtNode->rightSubtree = insert(AtNode->rightSubtree, key);
		
	if (key < AtNode->value)
		AtNode->leftSubtree = insert(AtNode->leftSubtree, key);
		
	//Update height
	AtNode->Height = Max(AtNode->leftSubtree, AtNode->rightSubtree) + 1;

	//When coming back up all the way to the root,
	//Make sure that every Node still has balance.
}

void main()
{
	system("PAUSE");
	return;
}
